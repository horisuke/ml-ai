### AWS Lambda実践ガイド
#### 1. Lambdaで実現するサーバレスシステム

##### 1-1. 管理の手間を削減しコスト削減を実現するLambda
* AWS環境でアプリケーションを構築する場合、プログラム実行環境として仮想サーバEC2インスタンスを用意し、その環境で動かすのが一般的だが、その運用には手間もコストもかかる。

###### 1-1-1. EC2インスタンスの運用上の問題
* EC2インスタンスは単純な仮想サーバであり、OSやプログラム実行環境、フレームワーク、ライブラリなどをインストールしてプログラムの実行環境を整える必要があるが、これらの実行環境構築は手間がかかる。
* 加えて運用も管理も大変である。インストールしたものに脆弱性が見つかれば、その脆弱性をふさぐためのアップデートをする必要がある。
* EC2には性能の問題もある。EC2はインスタンス起動時に選んだインスタンスタイプによって性能が決まる。インスタンスを一時停止すればインスタンスタイプを変更することはできるが、インスタンスが稼働している間は固定となる。
* そのため、急激な負荷増に耐えられないことがある。負荷に耐えるためには負荷を予測して適切なインスタンスタイプで起動しておいたり、負荷分散機能であるELB(Elastic Load Balancing)と負荷に応じてインスタンスの数を自動的に変更できるAuto Scalingの仕組みを組み合わせて、動的にインスタンス数を増減できる構成をとる、といった工夫が必要となる。
* こうしたEC2の運用の手間を軽減する方法の1つがLambdaである。

###### 1-1-2. アップロードした関数を実行してくれるLambda
* Lambdaはサーバレスアーキテクチャと呼ばれ、実行環境としてEC2のような仮想サーバは不要。
* 実行環境はAWSによって実行のたびに用意されるため、サーバシステムの保守・運用も不要。
* 負荷が高まれば、自動的にスケールするため、負荷増の場合の対応を考える必要もない(ただし、スケールできる同時実行数に制限はある)。
* Lambdaでプログラムを実行するためには実行したいプログラムを関数として実装し、Lambdaにアップロードするだけでよい。
* 実行する際に実行環境(コンテナ)が自動で作られ、プログラムが実行される。

###### 1-1-3. Lambdaの制限
* LambdaはEC2の完全置き換えにはならず、いくつか制限がある。
* ステートレス
    * Lambda関数は都度実行され、実行が終わると破棄される。前回実行時の状態などの保持はできない。
* 最大稼働時間は5分
    * Lambda関数は最大稼働時間を設定でき、最大5分。それ以上時間がかかる処理を実行することはできない。
* これらの制限を踏まえると、継続的に稼働する処理ではなく、必要に応じて少しだけ動く処理にLambdaは向いている。
* 継続的に稼働する処理は従来通り、EC2インスタンスの方が適している。

###### 1-1-4. 開発者に優しいLambda
* Lambdaは実行環境がAWSによって用意されるため、開発者は実行したい機能を関数として作り、それをアップロードするだけでよい。
* Lambdaを使ってシステムを作る場合、多くのLambda関数を作り、それを組み合わせて使う、という運用になる。
* 1つ1つのプログラムが小さく、それぞれが独立しているので、テストも容易になる。
* Lambda関数同士の結合にはAmazon SQSやAmazon SNSトピックを使用することで、関数を疎結合にすることも可能。

###### 1-1-5. Lambdaはコスト削減にも貢献する
* Lambdaの課金単位は実行時間。実行されていないときは費用がかからない。
* 例えば、「毎日0時にバッチを3分程度実行したい」とする。
* これをEC2インスタンスで構築する場合、インスタンスを起動したままにしておき、0時になったらプログラムを実行するよう、cronなどを設定しておくことになる。
* つまりEC2は24時間稼働し、実行されていることになる。
* 一方、Lambdaの場合、Lambda関数をアップロードして、0時に動かすというスケジューリングを設定しておくだけでよい。
* 実行時間が3分なら、3分間の実行コストしかかからないため、うまくLambdaで構成することで大幅なコスト削減を実現できる。

###### 1-1-6. Lambdaが利用できるリージョン
* Lambdaは主要なほとんどのリージョンで対応しているが、Lambdaとともに利用するサービスの中にはリージョンによってサポートされていないものもある。

##### 1-2. イベントドリブンの糊付けプログラミング
* Lambda関数は決まったスケジュールで動かすこともできるが、それ以外にAWSの様々なサービスと連携したタイミングで実行できる。

###### 1-2-1. Lambda関数を稼働させるイベントリソース
* Lambda関数はAWS上のサービスと連携して実行することができる。
* 実行のトリガーになるものをイベントソースと呼ぶ。
* 例えばストレージサービスであるAmazon S3は「ファイルが置かれたとき」などにLambda関数を呼び出すことができる。
* これを利用すれば、「画像ファイルがアップロードされたときにサムネイルを作る」とか「ファイルがアップロードされたときにパスワード付きの暗号化zipを作る」という処理が実現できる。
* 加えてAPI Gatewayと組み合わせると、Lambda関数をREST形式のWebAPIとして呼び出すことが可能となる。
* これを利用することで、HTMLの入力フォームでPOSTしたり、JavaScriptのAjaxで通信した結果をLambda関数で処理し、データベースに保存するといった処理もできる。

###### 1-2-2. LambdaはAWSのサービスをつなぎ合わせる
* Lambda関数は「AWSのサービスから呼び出され、何かの処理をして別のAWSサービスを実行する」という処理の構成になることがほとんどである。
* よって、Lambdaプログラミングのほとんどは様々なAWSサービスを糊付けするために使われる。そのため、どのようなAWSサービスがあり、どのように利用するものかという知識も不可欠になってくる。

##### 1-3. まとめ
* 上記まででLambdaを利用するメリット、またLambdaでは実現できないことがあることを説明。
* 最大の難関はLambdaにおけるプログラミングを習得する必要があるという点である。
* EC2インスタンス上で動くプログラムはオンプレミス環境の延長上であり、様々な従来の開発技術がそのまま使用できたが、LambdaはAWSが用意した実行環境上で動くため、様々な作法をLambdaに合わせる必要がある。
* よって、プログラミング技法はAWSに固有のものとなり、習得コストがかかる。
* ただLambdaは小さなプログラムを組み合わせてシステム全体を作る、という思想なので、1つ1つのプログラム規模は小さく、それほど難しくはない。小さなプログラムで十分な処理が可能である。

#### 2. Lambda事始め

##### 2-1. サンプル用Lambda関数の仕様
* AWSマネージメントコンソールを使って簡単なLambda関数を作る。
* Lambda関数のサンプル例として、「x」、「y」を引数として渡すと、その値をログに出力し、「x÷y」の計算結果を戻り値として返すものを考える。
* 引数は以下のようなJSON形式で渡すものとする。
   ```
   {"x" : 10, "y" : 2}
   ```
* 戻り値も以下のようなJSON形式で返るものとする。
   ```
   {"result" : 5}
   ```
* また、このとき受け取った引数 $x$, $y$ の値をCloudWatch Logsにログ出力するようにする。
* loudWatch Logsはログデータを使用してアプリケーションとシステムをモニタリングするAWSのサービスの1つ。

##### 2-2. Lambda関数の構造と設計
* Lambda関数を作るには関数の引数、戻り値の書式、エラーの返し方などLambda関数の基本的な決まりごとの理解が必要となる。
* 以下、Python3でプログラムを作成する。
###### 2-2-1. Lambda関数の書式
* Lambda関数はS3やSESなどで発生するイベントをトリガーにして呼び出され、Lambda関数は適切な実行環境の中で実行される。
* これらの実行環境の情報はコンテキストと呼ばれる。
* Lambda関数が実行される場合、イベント情報とコンテキスト情報が渡される。
* Python3の場合、下記のように「event」、「context」の2つの引数を取る書式で定義する。
   ```
   def myfunc_handler(event, context):
       ・・・関数の処理・・・
       return 戻り値
   ```
* Lambda関数はハンドラとも呼ばれ、慣例的に関数は「機能名_handler」とされることが多い。
* イベント引数はイベントから渡される任意の入力値である。渡ってくるデータ自体はJSON形式の文字列だが、Lambda関数に引数で渡される時点ではparseされ、関数の言語で扱いやすい形になっている。
* 例えば、以下のようなJSONがイベントから渡ってくるとする。
   ```
   {"x" : 10, "y" : 2}
   ```
* myfunc_handlerの引数eventには開発言語であるPython3に合わせ、event["x"], event["y"]として、それぞれ10, 2が取得できる。
* コンテキスト引数はコンテキスト(実行環境)の情報が含まれるオブジェクトである。
* 以下のような様々な環境情報を取得できる。
* Contextオブジェクトのメソッド：
    |Method|意味|
    |---|---|
    |get_remaining_time_in_millis()|実行可能な残時間(ミリ秒)を取得する|
* Contextオブジェクトのプロパティ：
    |Property|意味|
    |---|---|
    |function_name|Lambda関数の名前|
    |function_version|Lambda関数のバージョン|
    |invokcd_function_arn|Lambda関数の呼び出しに使われたARN|
    |memory_limit_in_mb|コンテキストに割り当てられているメモリ(MB)|
    |aws_request_id|リクエストに関連付けられたリクエストID|
    |log_group_name|CloudWatch Logsのロググループ名|
    |log_stream_name|CloudWatch Logsのログストリーム名|
    |identity|AWS Mobile SDK経由で呼び出された場合のCognito認証プロバイダに関する情報|
    |client_context|AWS Mobile SDK経由で呼び出された場合のクライアントアプリケーションの情報|
* 戻り値はPythonのreturn文を使って設定する。イベントの種類によっては戻り値が無視されることもある。
* Lambda関数からprint文などで標準出力した内容は全てCloudWatch Logsに書き出される。

###### 2-2-2. Lambda関数のサンプル
* プログラムの仕様
    * イベント引数として{"x":xの値, "y":yの値}を与えると、そのxとyをprintで出力し、「x÷y」の結果を{"result":答え}の形で返す。
* サンプルプログラム
    ```python
    import json

    def myfunc01_handler(event, context):
        x = int(event['x'])
        y = int(event['y'])
        print("x = " + str(x))
        print("y = " + str(y))
        retval = {'result' : x / y}
        return json.dumps(retval)
    ```
   * まず渡されたeventからｘとｙの値を取得する。JSON文字列として受け取るが、関数内ではすでにparseされているので、x, yの値はそれぞれ、```event['x']```, ```event['y']```で取得できる。
   * 「x÷y」を計算するために```int()```メソッドで文字列から整数に変換し、それぞれx, yに格納する。
   * それらの値は```print()```メソッドで標準出力に書き出すことでCloudWatch Logsに書き込まれる。
   * 最後に```json.dump()```メソッドでJSON文字列に変換して戻り値を設定する。

##### 2-3. Lambdaの利用に必要なアクセス権
* AWSマネージメントコンソールでLambda関数を作る前に必要なIAM(Identify and Access Management)ユーザとIAMロールを作成しておく必要がある。

###### 2-3-1. IAMユーザとIAMロール
* AWSアカウント作成時のメールアドレスとパスワードはルートアカウント(管理者アカウント)の認証情報である。
* この認証情報でサインインした場合、AWS全てのリソースにアクセスできるため、通常利用は推奨されていない。
* 通常、IAMユーザというアカウントを利用する。
* IAMユーザはAWSリソースに対するユーザ認証と用途ごとに細かいリソースへのアクセス権限を適用できる。
* ここではLambda関数を作成・実行・操作するためのIAMユーザを用意する。
* IAMロールはAWSリソースへのアクセス権限のことで、管理者がロールにアクセス権限を付与し、そのロールをIAMユーザに適用する。
* これにより、IAMユーザはAWSのリソースに適切にアクセスできるようになる。
* また、Lambda関数(AWSリソース)にロールを適用することで、Lambda関数から適切にAWSサービスやリソースにアクセスできるようになる。
* IAMユーザにはアクセスポリシーを付与する。アクセスポリシーには各種権限が含まれている。
* Lambda関数にはIAMロールを付与する。IAMロールはアクセスポリシーを付与することで作成する。同様にアクセスポリシーには各種権限が含まれている。

###### 2-3-2. Lambdaの利用に必要なアクセス権
* Lambdaを利用する場合、以下の3つのアクセス権が関与する。
* Lambda関数の作成権限：開発者用のIAMユーザの権限
    * 開発者はAWSマネジメントコンソールやAWS CLIなどを用い、AWS上にLambda関数を作成する権限「lambda:CreateFunction」が必要である。
    * この権限がない開発者はLambda関数が作成できない。
* Lambda関数の実行権限：開発者用のIAMユーザやイベント元の権限
    * Lambda関数を実行する権限は「lambda:InvokeFunction」であり、開発者が主導でLambda関数を実行する場合、開発者にこの権限が必要となる。
* Lambda関数からの操作権限：Lambda関数の権限
    * Lambda関数はログをCloudWatchLogsへ書き込むため、最低限CloudWatchLogsへの書き込み権限が必要。
    * 具体的には「logs:PutLogEvents」、「logs:CreateLogStream」、「logs:CreateLogGroup」の権限が必要。
    * Lambda関数にて、例えばS3を操作したり、DynampDBを操作したりする場合は、それぞれリソースへのアクセス権が必要となる。

###### 2-3-3. 既存の管理ポリシーを適用する
* これらのアクセス権をひとつずつ設定するのは煩雑なため、アクセス権の設定は通常、既存のアクセスポリシーを適用する。
* 既存のアクセスポリシーを適用するのは、大雑把な感じがあるが、簡単にIAMユーザやIAMロールを構成できる。
* 開発者が手動で実行するLambda関数を作る場合、以下のように構成する。
    * 開発者に割り当てるIAMユーザ
        * 通常、「AWSLambdaFullAccess」ポリシーを適用する。
        * このポリシーの適用により、Lambda関数を作成・実行が可能となる。
        * また、このポリシーにはLambda関数と一緒に使うことの多い、DynamoDBやS3などへの書き込み権限も付与されている。
    * Lambda関数に割り当てるIAMロール
        * 通常、「AWSLambdaBasicExecutionRole」ポリシーを適用する。
        * このポリシーの適用により、Lambda関数にCloudWatchLogsへの書き込みアクセス権(「logs:PutLogEvents」、「logs:CreateLogStream」、「logs:CreateLogGroup」)が付与される。

###### 2-3-4. IAMユーザとIAMロールを作成する
* 開発者のIAMユーザ(「AWSLambdaFullAccess」を適用したIAMユーザ)を作成
    * AWSコンソールにログインし、"サービス"からIAM(Identity and Access Management)を選択
    * "ユーザー"タブを選択し、ユーザー一覧を表示
    * "ユーザーを追加"ボタンを選択し、ユーザー名を入力(ここではdevuser)
    * "アクセスの種類"では"プログラムによるアクセス"、"AWSマネジメントコンソールへのアクセス"の両方をチェックする。
    * "AWSマネジメントコンソールへのアクセス"をチェックすると、以下が表示されるので、それぞれ以下の通り設定する。
        * コンソールのパスワード：自動生成パスワード
        * パスワードのリセットが必要：チェックを入れる
    * "次のステップ：アクセス権限"を選択
    * 作成するユーザーdevuserにアクセス権を付与する。ここでは既存のポリシー「AWSLambdaFullAccess」を付与するので、"既存のポリシーを直接アタッチ"を選択
    * ポリシー一覧から「AWSLambdaFullAccess」を探し、チェックを入れ、"次のステップ：確認"を選択
    * 確認画面が表示され、内容を確認し、"ユーザーの作成"を選択すると、作成したユーザーの"アクセスキーID"、"シークレットアクセスキー"、"パスワード"が発行される。
    * 非表示になっている項目は"表示"を選択して確認する。
    * 次に作成したIAMユーザでAWSコンソールに以下のリンクからログインする。
        * https://<アカウントID>.signin.aws.amazon.com/console
    * 上記にアクセスし、"アカウント"、"ユーザー名"、"パスワード"を入力し、"サインイン"を選択。
    * 次画面でパスワードを変更し、"パスワード変更の確認"を選択すると、AWSコンソールにログインできることを確認
        * devuser@horisuketestでログインされていることが確認可能。
    * 次に「AWSLambdaFullAccess」に加え、API Gateway, SES, SQS, SNSを操作する権限を追加する。
        * 「AWSLambdaFullAccess」にはLambda, DynamoDB, S3などへのフルアクセス権しかないため。
    * rootアカウントでAWSコンソールにサインインし直し、"サービス"からIAM(Identity and Access Management)を選択、"ユーザー"タブを選択し、ユーザー一覧を表示する。
    * 作成した"devuser"を選択して、"概要"を開き、"アクセス権限"タブで"アクセス権限の追加"を選択。
    * "既存のポリシーを直接アタッチ"を選択し、以下のポリシーにチェックを入れ、"アクセス権限の追加"を選択する。
        * AmazonAPIGatewayAdministrator
        * AmazonSESFullAccess
        * AmazonSQSFullAccess
        * AmazonSNSFunAccess
    * "devuser"の"概要"画面にて、選択したポリシーがアタッチされていることを確認
* Lambdaの実行ロールを作成
    * 「AWSLambdaBasicExecutionRole」を適用したIAMロールを作成する。作成するロール名は「role-lambdaexec」とする。
    * AWSコンソールにログインし、"サービス"からIAM(Identity and Access Management)を選択し、"ロール"タブを選択。
    * "ロールの作成"を選択し、ロールタイプとして"AWSサービス"を選択し、"Lambda"を選択する
    * "次のステップ：アクセス権限"を選択し、「AWSLambdaBasicExecutionRole」ポリシーをフィルタしてチェックをし、"次のステップ：確認"を選択する。
    * ロール名として「role-lambdaexec」を入力し、"ロールの作成"を選択すると、ロール一覧に作成したロールが表示されていることを確認する。
    * 次に作成したロールにS3, DynamoDB, SES, SQS, SNSの操作権限を付与する。
    * ロール一覧画面で作成したロール「role-lambdaexec」を選択し、"概要"を開く。
    * "アクセス権限"タブで"ポリシーをアタッチします"を選択し、以下のポリシーにチェックを入れる。
        * AmazonS3FullAccess
        * AmazonDynamoDBFullAccess
        * AmazonSESFullAcccss
        * AmazonSQSFullAcccss
        * AmazonSNSFunAcccss
    * "ポリシーのアタッチ"を選択し、「role-lambdaexec」に指定したロールがアタッチされていることを確認。

##### 2-4. Lambda関数の作成
* ※As of 2018/11/03
* AWSコンソールでLambda関数を作成する。
* ここでは、上記で作成した「AWSLambdaFullAccess」ポリシーが付与されたIAMアカウントを使用する。
* AWSコンソールに「devuser」でサインインし直し、"サービス"からLambdaを選択する。
* 関数未作成時はLambdaコンソールを開くと、"関数の作成"が表示されるので選択する。
* "関数の作成"画面では"一から作成"を選択し、以下を選択・入力し、"関数の作成"を選択する。
    * 名前：HelloLambda
    * ランタイム：Python3.6
    * ロール：既存のロールを選択
    * 既存のロール：role-lambdaexec
* HelloLambdaの設定タブに遷移し、トリガー(AWSのどのサービスによって、どういう状況で呼び出されるか)の選択を行う。
* ここではひとまずトリガーの追加は行わず、そのままにする。
* 関数コード部分にはデフォルトで以下のコードが記述されている。
    ```python
    import json

    def lambda_handler(event, context):
        # TODO implement
        return {
            "statusCode": 200,
            "body": json.dumps('Hello from Lambda!')
        }
    ```
* この部分を前述した以下のサンプルプログラムに書き換える。
* "コードエントリータイプ"をデフォルトの"コードをインラインで編集"から".zipファイルをアップロード"に変更することでzip形式でアーカイブしたものをアップロードすることもできる。
    ```python
    import json

    def myfunc01_handler(event, context):
        x = int(event['x'])
        y = int(event['y'])
        print("x = " + str(x))
        print("y = " + str(y))
        retval = {'result' : x / y}
        return json.dumps(retval)
    ```
* "ハンドラ"はLambda関数が呼び出されたときにそれを処理する関数のことでLambda関数をPythonで記述する場合、ハンドラは「ファイル名.関数名」で記述される。
* ここではハンドラは"lambda_function.myfunc01_handler"として設定する。
* 環境変数部分にはLambd関数から参照したい値がある場合に値を設定する。ここでは空欄のままとする。
* タグ部分でLambda関数にタグ付けが可能。タグをつけることにより、グループ化や検索が可能となる。ここでは利用せず、空欄のままとする。
* 実行ロール部分は前画面で設定したロールと選択した既存ロールが反映されているため、そのままにする。
* 基本設定部分ではそれぞれ、以下を入力・設定する
    * 説明：My first lambda function.
    * メモリ：128MB
    * タイムアウト：3秒
* "メモリ"ではLambda関数の使用するメモリを指定できる。メモリを必要とする処理をしたい場合や実行時間を短くしたい場合は大きな値を設定する方がよいが、費用も大きくなる。
* "タイムアウト"は値を大きくしても追加課金はされない。一方、大きくし過ぎて無限ループが発生するようなコードが実行されると、そのタイムアウト時間まで課金が発生する可能性がある。
* 以下の設定はそれぞれデフォルトのままとする。
    * ネットワーク > VPC：非VPC
        * Lambda関数からVPCに配置されたリソースにアクセスしたい場合にVPCを指定する。不要の場合は"非VPC"を指定する。
    * デバッグとエラー処理 > DLQリソース：なし
        * 非同期呼び出しが失敗した場合の通知方法を選択
    * 同時実行数 > 予約されていないアカウントの同時実行1000
* 全ての設定が完了したら、コンソール上部の"保存"を選択し、Lambda関数及びその設定を保存する。

##### 2-5. Lambda関数の実行
* ※As of 2018/11/03
* 作成したLambda関数を手動で実行して結果を確認する。Lambdaコンソールで「テストイベント」を定義することでLambda関数を手動実行することができる。
* Lambdaコンソールから作成した関数「HelloLambda」を選択すると、作成した関数が表示される。
* 上部の"テストイベントの選択"プルダウンから"テストイベントの設定"を選択する。
* テストイベントの設定画面で以下の通り、設定する
    * "新しいテストイベントの作成"を選択
    * イベントテンプレート：Hello World
    * イベント名：MyLambdaTestEvent
* また、Lambda関数は $x$, $y$ を入力として受け取り、"x÷y"の値を戻り値として返す関数なので、以下のようなJSONをテストイベントとして記載する。
    ```python
    {
      "x": 10,
      "y": 2
    }
    ```
* テストイベントを記載後、"作成"を選択すると、「HelloLambda」の設定画面に遷移する。
* 画面上部のテストイベント部分に作成したテストイベント「MyLambdaTestEvent」がセットされていることを確認し、"テスト"を選択する。
* テストの実行が終わるとダイアログが表示され、詳細タブを開くと、以下のような内容を確認できる。
    * 関数実行によって返された結果
        * "{\"result\": 5.0}"
    * 概要
        * 所要時間
        * 課金期間
        * 設定済みリソース
        * 使用中最大メモリ　など
    * ログ出力
        ```
        START RequestId: 7b8218c5-df88-11e8-bb42-a5af044d9512 Version: $LATEST
        x = 10
        y = 2
        END RequestId: 7b8218c5-df88-11e8-bb42-a5af044d9512
        REPORT RequestId: 7b8218c5-df88-11e8-bb42-a5af044d9512	Duration: 0.37 ms	Billed Duration: 100 ms 	Memory Size: 128 MB	Max Memory Used: 21 MB
        ```
* この処理に関するログはダイアログの(ログ)のリンクを選択し、CloudWatch Logsを開くか、"ログ出力"部分を確認する。
* "x=10", "y=2"はPythonのprint文の処理であることから、標準出力はCloudWatch Logsに出力されることがわかる。
* 一方、Lambda関数の処理でエラーや例外が発生した場合の動作を確認する。
* Lambdaコンソールのメニューから"テストイベントの設定"を選択し、保存したテストイベント"MyLambdaTestEvent"を以下の通り変更する。
    ```python
    {
      "x": 10,
      "y": 0
    }
    ```
* このテストイベントでLambda関数を実行すると、実行結果が失敗となり、詳細に以下が表示される。
    ```
    {
      "errorMessage": "division by zero",
      "errorType": "ZeroDivisionError",
      "stackTrace": [
        [
          "/var/task/lambda_function.py",
          8,
          "myfunc01_handler",
          "retval = {'result' : x / y}"
        ]
      ]
    }
    ```
* Pythonで例外が発生した場合は、"errorMessage"、"errorType"、"stackTrace"の値を含むJSONが返される。
* このエラー情報はLambda関数実行成功時と同様、ClousWatch Logsにも表示される。

##### 2-6. まとめ
* Lambda関数は前述の通り、以下の書式の関数である。
   ```
   def myfunc_handler(event, context):
       ・・・関数の処理・・・
       return 戻り値
   ```
* 一方、Lambda関数を実行するためにアクセス権を設定するなど特殊な側面もある。
* 上記では手作業でLambda関数を実行したが、AWSの各種サービスをトリガーとして実行する場合は、"event"引数にその時の様々な情報を格納し、Lambda関数が呼び出される。

#### 3. AWS Lambdaの仕組み

##### 3-1. イベントの発生とLambda関数
* Lambda関数が実行される際、始めにLambdaコンテナというLinuxベースコンテナが作られ、関数はその中で実行される。
* Lambda関数の実行のトリガとなるイベントには、プッシュモデルとストリームベースの2タイプがある。
* さらにプッシュモデルのイベントには同期呼び出しと非同期呼び出しがあり、どのタイプが使われるかはのイベントの種類によって異なる。

##### 3-2. Lambdaコンテナ
* 前章でLambdaコンソール上で関数を作り、手動で関数を呼び出し、実行を確認したが、仮想マシンの設定は行っていない。
* 以下ではLamnda関数がどういう環境で実行されていくかを確認する。

###### 3-2-1. LamndaコンテナはLinux環境
* Lambda関数が実行されるLamndaコンテナはAmazon Linuxが稼働するLinuxコンテナ環境であり、特定のAMIをベースにしている。
* LambdaコンテナはLinux環境なので、"/tmp"などの一時ディスク領域(最大512MBまで使用可能)や環境変数を利用することができる。動的に割り当てられるグローバルIPを利用して、インターネットの接続することも可能。
* Linuxの環境変数として以下が定義されている。
    |環境変数|意味|
    |---|---|
    |LAMBDA_TASK_ROOT|Lambda関数のコードが配置されたパス|
    |AWS_EXECUTION_ENV|実行環境のランタイムの種類 ex:AWS_Lambda_python3.6|
    |LAMBDA_RUNTIME_DIR|Lambdaランタイム関連ライブラリの場所|
    |AWS_REGION|実行されるリージョン名|
    |AWS_DEFAULT_REGION|実行されるリージョン名|
    |AWS_LAMBDA_LOG_GROUP_NAME|CloudWatchLogsのグループ名|
    |AWS_LAMBDA_LOG_STREAM_NAME|CloudWatchLogsのストリーム名|
    |AWS_LAMBDA_FUNCTION_NAME|Lambda関数名|
    |AWS_LAMBDA_FUNCTION_MEMORY|コンテナで利用できるメモリサイズ|
    |AWS_LAMBDA_FUNCTION_VERSION|Lambda関数のバージョン|
    |AWS_ACCESS_KEY|実行されているIAMロールに基づくアクセスキーID、シークレットキーID|
    |AWS_ACCESS_KEY_ID|実行されているIAMロールに基づくアクセスキーID、シークレットキーID|
    |AWS_SECRET_KEY|実行されているIAMロールに基づくアクセスキーID、シークレットキーID|
    |AWS_SECRET_ACCESS_KEY|実行されているIAMロールに基づくアクセスキーID、シークレットキーID|
    |AWS_SECRET_TOKEN|実行されているIAMロールに基づくアクセスキーID、シークレットキーID|
    |AWS_SECURITY_TOKEN|実行されているIAMロールに基づくアクセスキーID、シークレットキーID|
    |PATH|実行ファイルのパス|
    |LANG|ロケール ex:en_UTF8|
    |LD_LIBRARY_PATH|ライブラリパス|
    |NODE_PATH|Node.js環境のパス|
    |PYTHON_PATH|Python環境のパス|
* Lambda関数の実行環境はLinuxシステムなので、Lambda関数の作り方はEC2インスタンスのLinux環境の場合と全く同じ。
* またLambda関数から外部ライブラリを使用する場合、Lambda関数とともにライブラリも一緒にZIP形式でアーカイブしておくと、そのコンテナで展開され、実行することができる。
* バイナリでビルドが必要なライブラリであっても、Amazon Linux AMIで予めビルドしておいたものをZIP形式のアーカイブに同梱することで実行が可能となる。

###### 3-2-2. コンテナの再利用
* LambdaコンテナはEC2インスタンスに比べて、起動時間が短く、必要なメモリやCPUリソースも多くないが、負荷が全くないわけではなく、作成には多少の時間がかかる。
* よって、1度作成したLambdaコンテナはしばらく破棄せずにとっておき、次にLambda関数が実行されたときにそのコンテナを再利用し、2回目以降のLambda関数実行を高速化する仕組みが採用されている。
* そのため、既存のLambdaコンテナの有無によって、Lambda関数を処理する時間にばらつきが生じることになる。
* Lambdaコンテナは再利用される可能性があるため、以下のような注意点がある。
    * "/tmp"などに前回のデータが残っている可能性がある
        * Lamnda関数によって前回の実行時に"/tmp"などに書き込まれたデータが残っている可能性がある。
        * この状態は保証されているわけではないため、Lambda関数は"/tmp"が前回実行時と同じであることも、空であることも想定してはいけない。
        * Lambda関数はステートレスなため、前回の状態が失われること、前回実行したときのゴミが残っているかもしれないことを想定して作成する必要がある。
    * 実行ユーザが異なることがある
        * Lambda関数はLinuxシステム上のいずれかのユーザで実行されるが、それがいつも同じユーザとは限らない。つまり、1回目のLambda関数実行時のユーザとは別のユーザが同じLinuxコンテナを使ってLambda関数を実行する可能性がある。
* 上記を踏まえると、Lambda関数で"/tmp"を使用する場合は、関数の始めに"/tmp"の中身を削除しておくのがよさそうだが、2回目以降の実行が1回目と同じユーザとは限らないので、"/tmp"以下のファイルにパーミッションがなく、削除できない可能性がある。
* よって、Lambda関数の処理の最後に"/tmp"の中身を削除するのが良い。

###### 3-2-3. VPCへのアクセス
* デフォルトではLambdaコンテナはPublicな場所に配置されるため、privateネットワークであるVPCとは接続できない。
* LambdaコンテナからVPCに接続されたEC2やRDSのインスタンスと通信する必要がある場合、Lambda関数のVPCオプションを設定し、VPC上の任意のサブネットにLambdaコンテナを配置する構成にする。
* 上記のようにVPCを利用する場合、以下のようなデメリットがある。
    * 起動に時間がかかる
        * Lambdaコンテナが起動している場合は、コンテナが再利用されるため、起動時の遅延はない。
        * 一方、コンテナが起動していない場合は、ネットワークの初期化やDHCPによるIPアドレス割り当て等が行われるため、稼働できるまでには数十秒かかる。
    * 同時実行性が低下する
        * VPCに接続したLambdaコンテナはサブネットから動的にIPアドレスが割り当てられる。
        * サブネットで利用可能なIPアドレス数に空きが十分にないとLambdaコンテナを実行できず、実行時エラーが発生する。
        * Lambdaコンテナをサブネットに配置する場合は、IPアドレスの空きがある必要がある。
* 以下の手順でLambdaコンテナをサブネットに配置する。
    * Lambdaコンソールから"関数"メニューを選び、関数を選択する。
    * "設定"タブの"ネットワーク"セクションでプルダウンで"非VPC"から作成済みのVPCを選択する。
    * VPCを選択すると、"サブネット"、"セキュリティグループ"が選択できるようになる。
    * "サブネット"は1か所選択すれば動作するが、特定のサブネットに障害が発生しても問題なく稼働するよう、複数のサブネットの選択が推奨されている。
    * "セキュリティグループ"も作成済みのものを選択する。
    * これらの設定により、LamndaコンテナにENI(Elastic Network Interface)が構成され、指定したサブネットに配置され、サブネットから動的にIPアドレスが設定されるようになる。
    * Lambdaコンテナに動的にIPアドレスが設定されることにより、ENIを介してサブネット内の別のリソース(EC2, RDSなど)と通信できるようになる。
* LambdaコンテナをVPCに接続する場合、Lambda関数を実行するIAMロールに対して「LambdaVPCAccessExecutionRoleポリシー」のアタッチが必要となる。

##### 3-3. Lambda関数の実行
* Lambda関数が実行されるタイミングは様々で前章のようにLambdaコンソールから手動で呼び出したり、AWSリソースの様々なイベントから呼び出すこともできる。
* ただその呼び出し方法は目的とする処理内容によってことなる。

###### 3-3-1. プッシュモデルとストリームベース
* Lambda関数の実行のトリガとなるイベントには、プッシュモデルとストリームベースの2タイプがある。
* 「Amazon Kinesisデータストリーム」、「DynamoDBデータストリーム」以外はプッシュモデルのイベントとなる。

###### 3-3-2. プッシュモデルの実行
* プッシュモデルはイベントソースがLambda関数を呼び出すモデルのこと。
* 以下のような呼び出し方法がある。LambdaコンソールからのLambda関数実行は同期呼び出しとなっているが、多くの場合、非同期呼び出しが使われる。
    * 同期呼び出し
        * Lambda関数の実行が終わるまで呼び出し元に戻らない呼び出し方法。
        * 実行が終わると、Lambda関数の戻り値が呼び出し元に渡される。
    * 非同期呼び出し
        * イベントキューに送信され、呼び出し元にすぐに戻る呼び出し方法。
        * Lambda関数の戻り値は破棄される。
* 非同期呼び出し


###### 3-3-3. ストリームベースの実行
* Lambda関数がイベントソースを流れるデータをポーリングしてデータを取得するモデルのこと。














#### 4. aa
